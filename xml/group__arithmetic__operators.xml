<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="group__arithmetic__operators" kind="group">
    <compoundname>arithmetic_operators</compoundname>
    <title>Arithmetic Functions</title>
    <briefdescription>
<para>YAP implements several arithmetic functions, they are defined as fields in three enumerations, such that there is one enumeration per each different arity: <linebreak/>
 </para>
    </briefdescription>
    <detaileddescription>
<para>These are the binary numeric operators currently supported by YAP.</para>
<para><itemizedlist>
<listitem><para><ref refid="group__Arithmetic_1gabd82341cb7fc61c1880963eb8b1da8cb" kindref="member">arith0_op</ref> defines constants and arity 0 arithmetic functions</para>
<para>constant operators specifies the available arithmetic`constants&quot;

  - #arith1_op defines single argument arithmetic functions


    unary operators
 specifies the available unary arithmetic operators

  - #arith2_op defines binary arithmetic functions


    binary operators
 specifies the available binary arithmetic operators

Arithmetic expressions
in YAP may use the following operators:

 - &lt;b&gt;pi [ISO]&lt;/b&gt;&lt;p&gt;@anchor pi_0

   An approximation to the value of &lt;em&gt;pi&lt;/em&gt;, that is, the ratio of a circle&apos;s circumference to its diameter

 - &lt;b&gt;e&lt;/b&gt;&lt;p&gt;@anchor e_0

   Euler&apos;s number, the base of the natural logarithms

 - &lt;b&gt;epsilon&lt;/b&gt;&lt;p&gt;@anchor epsilon_0

   The difference between the float &lt;tt&gt;1.0&lt;/tt&gt; and the next largest floating point number

   - &lt;tt&gt;inf&lt;/tt&gt;@anchor inf_0

   Infinity according to the IEEE Floating-Point standard Note that evaluating this term will generate a domain error in the &lt;tt&gt;iso&lt;/tt&gt; language mode

   Note also that YAP supports &lt;tt&gt;+inf&lt;/tt&gt; and  &lt;tt&gt;-inf&lt;/tt&gt;

 - &lt;b&gt;nan (not a number)&lt;/b&gt;&lt;p&gt;@anchor nan_0

   Not-a-number according to the IEEE Floating-Point standard Note that evaluating this term will generate a domain error in the &lt;tt&gt;iso&lt;/tt&gt; language mode

 - &lt;b&gt;random&lt;/b&gt;&lt;p&gt;@anchor random_0

   A pseudo-random floating point number between 0 and 1

 - &lt;b&gt;signed_integer_random&lt;/b&gt;&lt;p&gt;@anchor random_0

   A pseudo-random integer number with 32 bits

 - &lt;b&gt;unsigned_integer_random&lt;/b&gt;&lt;p&gt;@anchor random_0

   A pseudo-random unsigned integer number with 32 bits

 - &lt;b&gt;cputime&lt;/b&gt;&lt;p&gt;@anchor cputime_0

   CPU time since YAP was invoked, in seconds

 - &lt;b&gt;heapused&lt;/b&gt;&lt;p&gt;@anchor heapused_0

   Heap (data-base) space used, in bytes

 - &lt;b&gt;local&lt;/b&gt;&lt;p&gt;@anchor local_0

   Local stack in use, in bytes

 - &lt;b&gt;$b&lt;/b&gt;&lt;p&gt;@anchor b_0

   current choicepoint

 - &lt;b&gt;$env&lt;/b&gt;&lt;p&gt;@anchor env_0

   Environment

 - &lt;b&gt;$tr&lt;/b&gt;&lt;p&gt;@anchor tr_0

   Trail in use

 - &lt;b&gt;$free_stack&lt;/b&gt;&lt;p&gt;@anchor free_stack_0

   Amount of free stack space, that is, free space between global and local stacks

 - &lt;b&gt;global&lt;/b&gt;&lt;p&gt;@anchor global_0

   Global stack in use, in bytes

 

  - &lt;b&gt;exp( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor exp_1

    Natural exponential

  - &lt;b&gt;log( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor log_1

    Natural logarithm

  - &lt;b&gt;log10( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor log10_1

    Decimal logarithm

  - &lt;b&gt;sqrt( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor sqrt_1

    Square root

  - &lt;b&gt;sin( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor sin_1

    Sine

  - &lt;b&gt;cos( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor cos_1

    Cosine

  - &lt;b&gt;tan( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor tan_1

    Tangent

  - &lt;b&gt;asin( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor asin_1

    Arc sine

  - &lt;b&gt;acos( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor acos_1

    Arc cosine

  - &lt;b&gt;atan( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor atan_1

    Arc tangent

  - &lt;b&gt;sinh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor sinh_1

    Hyperbolic sine

  - &lt;b&gt;cosh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor cosh_1

    Hyperbolic cosine

  - &lt;b&gt;tanh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor tanh_1

    Hyperbolic tangent

  - &lt;b&gt;asinh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor asinh_1

    Hyperbolic arc sine

  - &lt;b&gt;acosh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor acosh_1

    Hyperbolic arc cosine

  - &lt;b&gt;atanh( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor atanh_1

    Hyperbolic arc tangent

  - &lt;b&gt;lgamma( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor lgamma_1

    Logarithm of gamma function

  - &lt;b&gt;erf( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor erf_1

    Gaussian error function

  - &lt;b&gt;erfc( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor erfc_1

    Complementary gaussian error function

  - &lt;b&gt;random( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor random_1_op

    An integer random number between 0 and  &lt;em&gt;X&lt;/em&gt;

    In &lt;tt&gt;iso&lt;/tt&gt; language mode the argument must be a floating
    point-number, the result is an integer and it the float is equidistant
    it is rounded up, that is, to the least integer greater than  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;integer( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor integer_1_op

    If  &lt;em&gt;X&lt;/em&gt; evaluates to a float, the integer between the value of  &lt;em&gt;X&lt;/em&gt; and 0 closest to the value of  &lt;em&gt;X&lt;/em&gt;, else if  &lt;em&gt;X&lt;/em&gt; evaluates to an
    integer, the value of  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;float( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor float_1_op

    If  &lt;em&gt;X&lt;/em&gt; evaluates to an integer, the corresponding float, else the float itself

  - &lt;b&gt;float_fractional_part( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor float_fractional_part_1

    The fractional part of the floating point number  &lt;em&gt;X&lt;/em&gt;, or &lt;tt&gt;0.0&lt;/tt&gt; if  &lt;em&gt;X&lt;/em&gt; is an integer In the &lt;tt&gt;iso&lt;/tt&gt; language mode,  &lt;em&gt;X&lt;/em&gt; must be an integer

  - &lt;b&gt;float_integer_part( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor float_integer_part_1

    The float giving the integer part of the floating point number  &lt;em&gt;X&lt;/em&gt;, or  &lt;em&gt;X&lt;/em&gt; if  &lt;em&gt;X&lt;/em&gt; is an integer In the &lt;tt&gt;iso&lt;/tt&gt; language mode,  &lt;em&gt;X&lt;/em&gt; must be an integer

  - &lt;b&gt;abs( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor abs_1

    The absolute value of  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;ceiling( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor ceiling_1

    The integer that is the smallest integral value not smaller than  &lt;em&gt;X&lt;/em&gt;

    In &lt;tt&gt;iso&lt;/tt&gt; language mode the argument must be a floating point-number and the result is an integer

  - &lt;b&gt;floor( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor floor_1

    The integer that is the greatest integral value not greater than  &lt;em&gt;X&lt;/em&gt;

    In &lt;tt&gt;iso&lt;/tt&gt; language mode the argument must be a floating
    point-number and the result is an integer

  - &lt;b&gt;round( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor round_1

    The nearest integral value to  &lt;em&gt;X&lt;/em&gt; If  &lt;em&gt;X&lt;/em&gt; is equidistant to two integers, it will be rounded to the closest even integral value

    In &lt;tt&gt;iso&lt;/tt&gt; language mode the argument must be a floating point-number, the result is an integer and it the float is equidistant it is rounded up, that is, to the least integer greater than  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;sign( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor sign_1

    Return 1 if the  &lt;em&gt;X&lt;/em&gt; evaluates to a positive integer, 0 it if evaluates to 0, and -1 if it evaluates to a negative integer If  &lt;em&gt;X&lt;/em&gt;
    evaluates to a floating-point number return 1.0 for a positive  &lt;em&gt;X&lt;/em&gt;, 0.0 for 0.0, and -1.0 otherwise

  - &lt;b&gt;truncate( &lt;em&gt;X&lt;/em&gt;) [ISO]&lt;/b&gt;&lt;p&gt;@anchor truncate_1

    The integral value between  &lt;em&gt;X&lt;/em&gt; and 0 closest to &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;rational( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor rational_1_op

    Convert the expression  &lt;em&gt;X&lt;/em&gt; to a rational number or integer The function returns the input on integers and rational numbers For
    floating point numbers, the returned rational number exactly represents
    the float As floats cannot exactly represent all decimal numbers the
    results may be surprising In the examples below, doubles can represent
    &lt;tt&gt;0.25&lt;/tt&gt; and the result is as expected, in contrast to the result of
    &lt;tt&gt;rational(0.1)&lt;/tt&gt; The function &lt;tt&gt;@ref rationalize/1 &lt;/tt&gt; gives a more
    intuitive result

@code{prolog} 
?- A is rational(0.25).

A is 1 rdiv 4
?- A is rational(0.1).
A = 3602879701896397 rdiv 36028797018963968
@endcode
  - &lt;b&gt;rationalize( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor rationalize_1

    Convert the expression &lt;em&gt;X&lt;/em&gt; to a rational number or integer The function is
vvxu    similar to @ref rational_1 &quot;rational/1&quot;, but the result is only accurate within the
    rounding error of floating point numbers, generally producing a much
    smaller denominator

@code{prolog} 
?- A is rationalize(0.25).

A = 1 rdiv 4
?- A is rationalize(0.1).

A = 1 rdiv 10
@endcode
  - &lt;b&gt;\\  &lt;em&gt;X&lt;/em&gt; [ISO]&lt;/b&gt;&lt;p&gt;

    Integer bitwise negation

  - &lt;b&gt;msb( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor msb_1

    The most significant bit of the non-negative integer  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;lsb( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor lsb_1

    The least significant bit of the non-negative integer  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;popcount( &lt;em&gt;X&lt;/em&gt;)&lt;/b&gt;&lt;p&gt;@anchor popcount_1

    The number of bits set to &lt;tt&gt;1&lt;/tt&gt; in the binary representation of the non-negative integer  &lt;em&gt;X&lt;/em&gt;

  - &lt;b&gt;[ &lt;em&gt;X&lt;/em&gt;]&lt;/b&gt;&lt;p&gt;

    Evaluates to  &lt;em&gt;X&lt;/em&gt; for expression  &lt;em&gt;X&lt;/em&gt; Useful because character
strings in Prolog are lists of character codes

@code 
X is Y*10+C-&quot;0" </para>
</listitem></itemizedlist>
</para>
<para>is the same as</para>
<para><programlisting><codeline><highlight class="normal">X<sp/>is<sp/>Y*10+C-[48].</highlight></codeline>
</programlisting></para>
<para>which would be evaluated as:</para>
<para><programlisting><codeline><highlight class="normal">X<sp/>is<sp/>Y*10+C-48.</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para>*_X_+ <emphasis>Y</emphasis> [ISO]*</para>
</listitem></itemizedlist>
</para>
<para>Addition, implemented between any two types of numbers</para>
<para><itemizedlist>
<listitem><para>*_X_- <emphasis>Y</emphasis> [ISO]*</para>
</listitem></itemizedlist>
</para>
<para>Addition, implemented between any two types of numbers</para>
<para><itemizedlist>
<listitem><para>*_X_* <emphasis>Y</emphasis> [ISO]*</para>
</listitem></itemizedlist>
</para>
<para>Product</para>
<para><itemizedlist>
<listitem><para>*_X_/ <emphasis>Y</emphasis> [ISO]*</para>
</listitem></itemizedlist>
</para>
<para>Quotient</para>
<para>The result of <emphasis>Y</emphasis>/0.0 may return the value <computeroutput>inf</computeroutput>, or it may generate an exception, depending on the value of the Prolog flag <computeroutput>arithmetic_exceptions</computeroutput></para>
<para>The next example shows zero division handling If the flag is enabled:</para>
<para><programlisting><codeline><highlight class="normal">?-<sp/>X<sp/>is<sp/>2/0.</highlight></codeline>
<codeline><highlight class="normal">ERROR!!</highlight></codeline>
<codeline><highlight class="normal">ZERO<sp/>DIVISOR<sp/>ERROR-<sp/>X<sp/>is<sp/>Exp</highlight></codeline>
</programlisting></para>
<para>If disabled: <programlisting><codeline><highlight class="normal">?-<sp/>X<sp/>is<sp/>2/0.</highlight></codeline>
<codeline><highlight class="normal">X<sp/>=<sp/>(+inf).</highlight></codeline>
</programlisting> It is <computeroutput>true</computeroutput> by default, but it is disabled by packages like CLP(BN) and</para>
<para>By default the flag is set to <computeroutput>false</computeroutput></para>
<para><itemizedlist>
<listitem><para>*_X_// <emphasis>Y</emphasis> [ISO]*</para>
<para>Integer quotient</para>
</listitem><listitem><para>*_X_ mod <emphasis>Y</emphasis> [ISO]*<anchor id="group__arithmetic__operators_1mod_2"/> Integer module operator, always positive</para>
</listitem><listitem><para>*_X_ rem <emphasis>Y</emphasis> [ISO]*<anchor id="group__arithmetic__operators_1rem_2"/> Integer remainder, similar to <computeroutput>mod</computeroutput> but always has the same sign as <computeroutput>X</computeroutput></para>
</listitem><listitem><para>* <emphasis>X</emphasis> div <emphasis>Y</emphasis> [ISO]*<anchor id="group__arithmetic__operators_1div_2"/> Integer division, as if defined by <computeroutput>( _X_ - _X_ mod _Y_)// _Y_</computeroutput></para>
</listitem><listitem><para><emphasis>max( <emphasis>X</emphasis>, <emphasis>Y</emphasis>) [ISO]</emphasis><anchor id="group__arithmetic__operators_1max_2"/> The greater value of <emphasis>X</emphasis> and <emphasis>Y</emphasis></para>
</listitem><listitem><para><emphasis>min( <emphasis>X</emphasis>, <emphasis>Y</emphasis>) [ISO]</emphasis><anchor id="group__arithmetic__operators_1min_2"/> The lesser value of <emphasis>X</emphasis> and <emphasis>Y</emphasis></para>
</listitem><listitem><para>*_X_ ^ <emphasis>Y</emphasis> [ISO]*</para>
<para><emphasis>X</emphasis> raised to the power of <emphasis>Y</emphasis>, (from the C-Prolog syntax)</para>
</listitem><listitem><para><emphasis>exp( <emphasis>X</emphasis>, <emphasis>Y</emphasis>)</emphasis><anchor id="group__arithmetic__operators_1exp_2"/> <emphasis>X</emphasis> raised to the power of <emphasis>Y</emphasis>, (from the Quintus Prolog syntax)</para>
</listitem><listitem><para>*_X_ ** <emphasis>Y</emphasis> [ISO]*</para>
<para><emphasis>X</emphasis> raised to the power of <emphasis>Y</emphasis> (from ISO)</para>
</listitem><listitem><para>*_X_ /\ <emphasis>Y</emphasis> [ISO]*</para>
<para>Integer bitwise conjunction</para>
</listitem><listitem><para>*_X_ \/ <emphasis>Y</emphasis> [ISO]*</para>
<para>Integer bitwise disjunction</para>
</listitem><listitem><para>*_X_ # <emphasis>Y</emphasis>*</para>
<para>Integer bitwise exclusive disjunction</para>
</listitem><listitem><para>*_X_ &gt;&lt; <emphasis>Y</emphasis>*</para>
<para>Integer bitwise exclusive disjunction</para>
</listitem><listitem><para><emphasis>xor( <emphasis>X</emphasis> , <emphasis>Y</emphasis>) [ISO]</emphasis><anchor id="group__arithmetic__operators_1xor_2"/> Integer bitwise exclusive disjunction</para>
</listitem><listitem><para>*_X_ &lt;&lt; <emphasis>Y</emphasis>*</para>
<para>Integer bitwise left logical shift of <emphasis>X</emphasis> by <emphasis>Y</emphasis> places</para>
</listitem><listitem><para>*_X_ &gt; <emphasis>Y</emphasis> [ISO]*</para>
<para>Integer bitwise right logical shift of <emphasis>X</emphasis> by <emphasis>Y</emphasis> places</para>
</listitem><listitem><para><emphasis>gcd( <emphasis>X</emphasis>, <emphasis>Y</emphasis>)</emphasis><anchor id="group__arithmetic__operators_1gcd_2"/> The greatest common divisor of the two integers <emphasis>X</emphasis> and <emphasis>Y</emphasis></para>
</listitem><listitem><para><emphasis>atan( <emphasis>X</emphasis>, <emphasis>Y</emphasis>)</emphasis><anchor id="group__arithmetic__operators_1atan_2"/> Four-quadrant arc tangent Also available as <computeroutput>atan2/2 </computeroutput></para>
</listitem><listitem><para><emphasis>atan2( <emphasis>X</emphasis>, <emphasis>Y</emphasis>) [ISO]</emphasis><anchor id="group__arithmetic__operators_1atan2_2"/> Four-quadrant arc tangent</para>
</listitem><listitem><para>* <emphasis>X</emphasis> rdiv <emphasis>Y</emphasis> [ISO]*<anchor id="group__arithmetic__operators_1rdiv_2"/> Rational division </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
  </compounddef>
</doxygen>

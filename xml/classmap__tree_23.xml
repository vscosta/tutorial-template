<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.3" xml:lang="en-US">
  <compounddef id="classmap__tree_23" kind="predicate" language="Prolog" prot="public">
    <compoundname>map_tree/3</compoundname>
    <briefdescription>
<para><bold>map_tree</bold>(+ <emphasis>Pred</emphasis>, + <emphasis>OldTree</emphasis>, - <emphasis>NewTree</emphasis>) </para>
    </briefdescription>
    <detaileddescription>
<para>Holds when <emphasis>OldTree</emphasis> and <emphasis>NewTree</emphasis> are binary trees of the same shape and <computeroutput>Pred(Old,New)</computeroutput> is true for corresponding elements of the two trees</para>
<para>is true when OldTree and NewTree are binary trees of the same shape and Pred(Old,New) is true for corresponding elements of the two trees In fact this routine is perfectly happy constructing either tree given the other, I have given it the mode I have for that bogus reason &quot;efficiency&quot; and because it is normally used this way round This is really meant more as an illustration of how to map over trees than as a tool for everyday use </para>
    </detaileddescription>
    <location file="library/trees.yap" line="1" column="1" bodyfile="library/trees.yap" bodystart="1" bodyend="-1"/>
    <listofallmembers>
    </listofallmembers>
  </compounddef>
</doxygen>
